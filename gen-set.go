// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package setof

import (
	"encoding/json"
	"sort"
	"sync/atomic"
)

// Strings creates a new set of Strings.
func Strings(values ...string) *StringSet {
	ss := &StringSet{
		mapKeysToIndex: make(map[string]int64),
	}
	for _, v := range values {
		ss.Add(v)
	}
	return ss
}

// StringSet is a set of Strings which retains the order that the keys were added.
type StringSet struct {
	mapKeysToIndex map[string]int64
	index          int64
}

// Add an item to the set.
func (s *StringSet) Add(v string) {
	if _, ok := s.mapKeysToIndex[v]; ok {
		return
	}
	s.mapKeysToIndex[v] = atomic.AddInt64(&s.index, 1)
}

// Contains determines whether an item is in the set.
func (s *StringSet) Contains(v string) (ok bool) {
	_, ok = s.mapKeysToIndex[v]
	return
}

// Del deletes an item from the set.
func (s *StringSet) Del(v string) {
	delete(s.mapKeysToIndex, v)
}

// Values returns all of the values within the set.
func (s *StringSet) Values() (v []string) {
	values := make(indexToStringValues, len(s.mapKeysToIndex))
	var index int
	for k, v := range s.mapKeysToIndex {
		values[index] = indexToStringValue{
			index: v,
			value: k,
		}
		index++
	}
	sort.Sort(values)
	v = make([]string, len(s.mapKeysToIndex))
	for i, vv := range values {
		v[i] = vv.value
	}
	return
}

type indexToStringValue struct {
	index int64
	value string
}

type indexToStringValues []indexToStringValue

func (d indexToStringValues) Len() int {
	return len(d)
}

func (d indexToStringValues) Swap(i, j int) {
	d[i], d[j] = d[j], d[i]
}

func (d indexToStringValues) Less(i, j int) bool {
	return d[i].index < d[j].index
}

// MarshalJSON marshals to JSON.
func (s *StringSet) MarshalJSON() ([]byte, error) {
	return json.Marshal(s.Values())
}

// UnmarshalJSON marshals from JSON.
func (s *StringSet) UnmarshalJSON(data []byte) error {
	var a []string
	err := json.Unmarshal(data, &a)
	if err != nil {
		return err
	}
	(*s) = (*Strings(a...))
	return nil
}

// Ints creates a new set of Ints.
func Ints(values ...int) *IntSet {
	ss := &IntSet{
		mapKeysToIndex: make(map[int]int64),
	}
	for _, v := range values {
		ss.Add(v)
	}
	return ss
}

// IntSet is a set of Ints which retains the order that the keys were added.
type IntSet struct {
	mapKeysToIndex map[int]int64
	index          int64
}

// Add an item to the set.
func (s *IntSet) Add(v int) {
	if _, ok := s.mapKeysToIndex[v]; ok {
		return
	}
	s.mapKeysToIndex[v] = atomic.AddInt64(&s.index, 1)
}

// Contains determines whether an item is in the set.
func (s *IntSet) Contains(v int) (ok bool) {
	_, ok = s.mapKeysToIndex[v]
	return
}

// Del deletes an item from the set.
func (s *IntSet) Del(v int) {
	delete(s.mapKeysToIndex, v)
}

// Values returns all of the values within the set.
func (s *IntSet) Values() (v []int) {
	values := make(indexToIntValues, len(s.mapKeysToIndex))
	var index int
	for k, v := range s.mapKeysToIndex {
		values[index] = indexToIntValue{
			index: v,
			value: k,
		}
		index++
	}
	sort.Sort(values)
	v = make([]int, len(s.mapKeysToIndex))
	for i, vv := range values {
		v[i] = vv.value
	}
	return
}

type indexToIntValue struct {
	index int64
	value int
}

type indexToIntValues []indexToIntValue

func (d indexToIntValues) Len() int {
	return len(d)
}

func (d indexToIntValues) Swap(i, j int) {
	d[i], d[j] = d[j], d[i]
}

func (d indexToIntValues) Less(i, j int) bool {
	return d[i].index < d[j].index
}

// MarshalJSON marshals to JSON.
func (s *IntSet) MarshalJSON() ([]byte, error) {
	return json.Marshal(s.Values())
}

// UnmarshalJSON marshals from JSON.
func (s *IntSet) UnmarshalJSON(data []byte) error {
	var a []int
	err := json.Unmarshal(data, &a)
	if err != nil {
		return err
	}
	(*s) = (*Ints(a...))
	return nil
}

// Int64s creates a new set of Int64s.
func Int64s(values ...int64) *Int64Set {
	ss := &Int64Set{
		mapKeysToIndex: make(map[int64]int64),
	}
	for _, v := range values {
		ss.Add(v)
	}
	return ss
}

// Int64Set is a set of Int64s which retains the order that the keys were added.
type Int64Set struct {
	mapKeysToIndex map[int64]int64
	index          int64
}

// Add an item to the set.
func (s *Int64Set) Add(v int64) {
	if _, ok := s.mapKeysToIndex[v]; ok {
		return
	}
	s.mapKeysToIndex[v] = atomic.AddInt64(&s.index, 1)
}

// Contains determines whether an item is in the set.
func (s *Int64Set) Contains(v int64) (ok bool) {
	_, ok = s.mapKeysToIndex[v]
	return
}

// Del deletes an item from the set.
func (s *Int64Set) Del(v int64) {
	delete(s.mapKeysToIndex, v)
}

// Values returns all of the values within the set.
func (s *Int64Set) Values() (v []int64) {
	values := make(indexToInt64Values, len(s.mapKeysToIndex))
	var index int
	for k, v := range s.mapKeysToIndex {
		values[index] = indexToInt64Value{
			index: v,
			value: k,
		}
		index++
	}
	sort.Sort(values)
	v = make([]int64, len(s.mapKeysToIndex))
	for i, vv := range values {
		v[i] = vv.value
	}
	return
}

type indexToInt64Value struct {
	index int64
	value int64
}

type indexToInt64Values []indexToInt64Value

func (d indexToInt64Values) Len() int {
	return len(d)
}

func (d indexToInt64Values) Swap(i, j int) {
	d[i], d[j] = d[j], d[i]
}

func (d indexToInt64Values) Less(i, j int) bool {
	return d[i].index < d[j].index
}

// MarshalJSON marshals to JSON.
func (s *Int64Set) MarshalJSON() ([]byte, error) {
	return json.Marshal(s.Values())
}

// UnmarshalJSON marshals from JSON.
func (s *Int64Set) UnmarshalJSON(data []byte) error {
	var a []int64
	err := json.Unmarshal(data, &a)
	if err != nil {
		return err
	}
	(*s) = (*Int64s(a...))
	return nil
}
